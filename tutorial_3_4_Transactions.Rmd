Postgres documentation - Beginners tutorial
===========================================

3.1 Introduction to Advanced Features
-------------------------------------

Advanced features, including management tips, loss or corruption prevention, and some basic extensions

3.2 Views
---------

So a view, is kind of like an object. You can create a 'view', which seems to be basically a shortcut for some query you have used previously.

```{sql}

CREATE VIEW myview AS
    SELECT city, temp_lo, temp_hi, prcp, date, location
	FROM weather, cities
	WHERE city = name;

```

Here I've stored the query (beginning with 'SELECT') inside the 'view' named 'myview'

But a 'view' is not simply a window, because it can be embedded inside another view, implying that it can be operated on?

Using views often is good database design and practise

3.3 Foreign Keys
----------------

Only the most basic introduction here, but considered extremely important to high quality database management

They basically provide a hard link between two tables, such that one cannot insert values in one that do not match another.

```{sql}

-- The new declaration of the tables would look like this:

CREATE TABLE cities (
        city     varchar(80) primary key,
        location point
);

CREATE TABLE weather (
        city      varchar(80) references cities(city),
        temp_lo   int,
        temp_hi   int,
        prcp      real,
        date      date
);

-- Now try inserting an invalid record:

INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');
-- ERROR:  insert or update on table "weather" violates foreign key constraint "weather_city_fkey"
-- DETAIL:  Key (city)=(Berkeley) is not present in table "cities".

```

How then, do you insert a row that doesn't violate this? Insert into both tables at the same time?

How?

Note: Take a look at Chapter 5!!

    file:///usr/local/Cellar/postgresql/12.1/share/doc/postgresql/html/ddl.html

3.4 Transactions
----------------

A *fundamental* concept... bundling multiple steps into a single 'all-or-nothing' operation

If you want make updates to, for example, banking transactions, you absolutely do not want to be in a situation where one part of the transaction suceeds (maybe a debit to one account), and another part fails (the credit to the corresponding account) which would leave the system in disequilibrium, and the customers would not be happy.

It's easy to see why it's important that these operations perform as an 'all-or-nothing' scenario. You need a computationally guaranteed way of achieving this.

A transaction is set up by wrapping the block in `BEGIN` and `COMMIT` commands.

```{sql}

BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
UPDATE branches SET balance = balance - 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
UPDATE branches SET balance = balance + 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');
COMMIT;

```

If partwat through a transaction, a problem occurs, the 'ROLLBACK' command will end the transaction, as if nothing happened.

Note: PostGreSQL implicitly treats all statements as transactions.

Furthermore, transaction blocks can be further micromanaged using *savepoints*.

```{sql}

BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
-- wait that's not right, it's supposed to be Wayne!
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Wayne';
COMMIT;

```

Note: the table 'accounts' doesn't exist in mydb, these are just examples taken from the tutorial pages.

3.5 Window Functions
--------------------

Window functions work similar to aggregate functions, except that it retains the individual rows. You can perform operations on sets of rows and apply the result to each row individually.

```{sql}

SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname)  FROM empsalary;

```

Note: the table 'empsalary' doesn't exist in mydb, these are just examples taken from the tutorial pages.

More details about window functions can be found in Section 4.2.8, Section 9.21, Section 7.2.5, and the SELECT reference page.

The key here in this statement is the `OVER` clause. This prompts the statement to be treated as a window function, instead of an aggregate function.

the `OVER` clause always follows the aggregate command, and is followed by the directive, i.e. the conditions for the processing of the aggregate function.

```{sql}

SELECT depnam, empno, salary,
    rank() OVER (PARTITION BY depname ORDER BY salary DESC)
FROM empsalary;

```

The rest of the stuff in this tutorial seems pretty abstract. Hard to really conceptualize without a dataset. So I'd have to either create a dataset the same as the examples used, or one similar.

How to add a lot of rows quickly?
  - What about that stuff before about sym linking tables?
  - Can I just start my own database project and go from there?

Maybe I should work my way through this tutorial as best I can, then start my project afterwards, and come back to these sections as needed.

I just need to remember that 'window functions' are operations on a set of related rows, as designated by the `OVER` () Clause

> Window functions are permitted only in the `SELECT` list and the `ORDER BY` clause of the query. They are forbidden elsewhere, such as in `GROUP BY`, `HAVING` and `WHERE` clauses. This is because they logically execute after the processing of those clauses. Also, window functions execute after non-window aggregate functions. This means it is valid to include an aggregate function call in the arguments of a window function, but not vice versa.

Always remember that you can use a sub-select to perform operations inside `GROUP BY`, `HAVING` and `WHERE` clauses.

> More details about window functions can be found in 
> - [Section 4.2.8](file:///usr/local/Cellar/postgresql/12.1/share/doc/postgresql/html/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS), 
> - [Section 9.21](file:///usr/local/Cellar/postgresql/12.1/share/doc/postgresql/html/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS), 
> - [Section 7.2.5](file:///usr/local/Cellar/postgresql/12.1/share/doc/postgresql/html/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS), and the 
> - [SELECT](file:///usr/local/Cellar/postgresql/12.1/share/doc/postgresql/html/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS) reference page.

3.6 Inheritance
---------------

*This is the creative, but inefficient way*

```{sql}

CREATE TABLE capitals (
  name	      text,
  population  real,
  altitude    int,	-- feet
  state	      char(2)
);

CREATE TABLE non_capitals (
  name	      text,
  population  real,
  altitude    int,	-- feet
);

CREATE VIEW cities AS
  SELECT name, population, altitude FROM capitals
    UNION
  SELECT name, population, altitude FROM non_capitals;

```

However, this requires a lot of work when it comes to updating several rows at once, among other things.

*This is a better way*

```{sql}

CREATE TABLE cities (
  name	      text,
  populations real,
  altitude    int     -- feet
);

CREATE TABLE capitals (
  state char(2)
) INHERITS (cities);

SELECT name, altitude
  FROM cities
  WHERE altitude > 500;

SELECT name, altitude
  FROM ONLY cities
  WHERE altitude > 500;

```

Inheritance is a powerful tool, but has not yet been integrated with other SQL functions, such as unique contraints and foreign keys.

See [here](file:///usr/local/Cellar/postgresql/12.1/share/doc/postgresql/html/ddl-inherit.html) for more detail on inheritance.

[//]: # ( OK, I seriously need to just start creating random tables, and start quickly figuring how to add rows )



---

[//]: # ( Note: just visual select everything below, and periodically save :w! tutorial_ImportantCommands.Rmd )

Postgres documentation - Beginners tutorial
===========================================

Important SQL Clauses
---------------------

```{sql}

SELECT
FROM
WHERE
GROUP BY
ORDER BY
HAVING
LIKE
UPDATE
DELETE

BEGIN
COMMIT
SAVEPOINT
ROLLBACK

OVER
PARTITION BY

INHERIT

-- What's the difference between syntax highlighting? What groups them together?


-- Aggregate functions

min()
max()
sum()
avg()
rank()

```

`WHERE` selects input rows before groups and aggregates are computed (thus, it controls which rows go into the aggregate computation), 
whereas `HAVING` selects group rows after groups and aggregates are computed.

Is it bad practise to simply use `table weather;` to view a table, instead of `SELECT * FROM weather;`




